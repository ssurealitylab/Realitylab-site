<!-- Reality Lab Chatbot -->
<div id="chatbot-container" class="chatbot-container" style="display: none;">
  
  <div id="chatbot-window" class="chatbot-window">
    <div class="chatbot-header">
      <div class="chatbot-header-info">
        <div class="chatbot-title">Reality Lab Assistant</div>
        <div class="chatbot-subtitle">AI가 연구실에 대해 답변해드립니다!</div>
      </div>
      <div class="chatbot-controls">
        <div class="mode-toggle">
          <div class="toggle-labels">
            <span class="toggle-label ai-label active">AI</span>
            <span class="toggle-label search-label">검색</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="mode-toggle" class="toggle-input" checked>
            <label for="mode-toggle" class="toggle-slider"></label>
          </div>
        </div>
        <button id="chatbot-close" class="chatbot-close">
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M15 5L5 15M5 5L15 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
    </div>
    
    <div id="chatbot-messages" class="chatbot-messages">
      <div class="message bot-message">
        <div class="message-content">
          안녕하세요! Reality Lab Assistant입니다. 🤖<br>
          연구실에 대해 궁금한 것이 있으시면 언제든 물어보세요!
        </div>
      </div>
    </div>
    
    <div class="chatbot-input-container">
      <input type="text" id="chatbot-input" class="chatbot-input" placeholder="궁금한 것을 물어보세요..." maxlength="200">
      <button id="chatbot-send" class="chatbot-send">
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
    </div>
    
    <div class="chatbot-suggestions">
      <div class="suggestion-chips">
        <button class="suggestion-chip" data-question="연구 분야가 뭔가요?" data-question-en="What are your research areas?">연구 분야</button>
        <button class="suggestion-chip" data-question="팀 구성원은 누구인가요?" data-question-en="Who are the team members?">팀 구성원</button>
        <button class="suggestion-chip" data-question="연구실에 지원하려면 어떻게 해야 하나요?" data-question-en="How can I apply to the lab?">지원 방법</button>
        <button class="suggestion-chip" data-question="연락처를 알려주세요" data-question-en="Please provide contact information">연락처</button>
      </div>
      
      <div class="language-buttons">
        <!-- AI Info tooltip moved to left -->
        <div class="ai-info-wrapper">
          <div class="ai-info-trigger" id="ai-info-trigger">
            <div class="ai-info-icon">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M12 17h.01" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
            <span class="ai-info-text" id="ai-info-text">이 AI는 어떻게 동작하나요?</span>
          </div>
          <div class="ai-info-tooltip" id="ai-info-tooltip">
            <button class="tooltip-close" id="tooltip-close">
              <svg width="16" height="16" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M15 5L5 15M5 5L15 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <div class="tooltip-content">
              <div class="tooltip-ko">
                <h4>🤖 Reality Lab AI Assistant</h4>
                <p><strong>모델:</strong> Qwen3-4B Fine-tuned 모델</p>
                <p><strong>하드웨어:</strong> NVIDIA RTX 4090 GPU</p>
                <p><strong>개발:</strong> 김희원 교수님과 연구실 학생들이 직접 참여</p>
                <p><strong>업데이트:</strong> 연구실 구성원들의 참여로 비정기적 업데이트</p>
                <br>
                <p><strong>동작 방식:</strong></p>
                <p>• <em>검색 모드:</em> 사전 구축된 Knowledge Base에서 정보 검색</p>
                <p>• <em>AI 서버 모드:</em> Fine-tuned Qwen3-4B가 자연어로 실시간 답변 생성</p>
                <br>
                <p><strong>GitHub:</strong> <a href="https://github.com/ssurealitylab-spec/Realitylab-site" target="_blank" style="color: #4fc3f7; text-decoration: underline;">github.com/ssurealitylab-spec/Realitylab-site</a></p>
              </div>
              <div class="tooltip-en" style="display: none;">
                <h4>🤖 Reality Lab AI Assistant</h4>
                <p><strong>Model:</strong> Fine-tuned Qwen3-4B</p>
                <p><strong>Hardware:</strong> NVIDIA RTX 4090 GPU</p>
                <p><strong>Development:</strong> Prof. Heewon Kim and lab students directly involved</p>
                <p><strong>Updates:</strong> Irregular updates with lab members' participation</p>
                <br>
                <p><strong>How it works:</strong></p>
                <p>• <em>Search Mode:</em> Searches pre-built Knowledge Base</p>
                <p>• <em>AI Server Mode:</em> Fine-tuned Qwen3-4B generates real-time natural language responses</p>
                <br>
                <p><strong>GitHub:</strong> <a href="https://github.com/ssurealitylab-spec/Realitylab-site" target="_blank" style="color: #4fc3f7; text-decoration: underline;">github.com/ssurealitylab-spec/Realitylab-site</a></p>
              </div>
            </div>
          </div>
        </div>
        
        <button class="lang-btn active" data-lang="ko">KOR</button>
        <button class="lang-btn" data-lang="en">ENG</button>
      </div>
    </div>
  </div>
</div>

<style>
/* Chatbot Styles */
.chatbot-container {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 1000;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.chatbot-window {
  position: absolute;
  bottom: 80px;
  right: 0;
  width: 450px;
  height: 600px;
  min-width: 320px;
  min-height: 400px;
  max-width: 800px;
  max-height: 800px;
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 16px;
  display: none;
  flex-direction: column;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  resize: both;
  overflow: hidden;
}

.chatbot-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  cursor: move;
  user-select: none;
  background: linear-gradient(135deg, rgba(51, 102, 204, 0.1) 0%, rgba(41, 84, 179, 0.15) 100%);
  backdrop-filter: blur(10px);
  border-radius: 16px 16px 0 0;
}

.chatbot-title {
  font-size: 16px;
  font-weight: 600;
  color: #1a1a1a;
}

.chatbot-subtitle {
  font-size: 12px;
  color: #6b7280;
  margin-top: 2px;
}

.chatbot-close {
  background: none;
  border: none;
  cursor: pointer;
  color: #6b7280;
  padding: 4px;
  border-radius: 6px;
}

.chatbot-close:hover {
  background: rgba(0, 0, 0, 0.05);
}

.chatbot-controls {
  display: flex;
  align-items: center;
  gap: 16px;
}

.mode-toggle {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.toggle-labels {
  display: flex;
  gap: 8px;
  font-size: 11px;
  font-weight: 500;
}

.toggle-label {
  color: #6b7280;
  transition: color 0.2s ease;
}

.toggle-label.active {
  color: #3366cc;
  font-weight: 600;
}

.toggle-switch {
  position: relative;
  width: 44px;
  height: 24px;
}

.toggle-input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #3366cc;
  border-radius: 24px;
  transition: all 0.3s ease;
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 20px;
  width: 20px;
  left: 0px;
  top: -2px;
  background: white;
  border-radius: 50%;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.toggle-input:checked + .toggle-slider {
  background: #10b981;
}

.toggle-input:checked + .toggle-slider:before {
  transform: translateX(25px);
}



.chatbot-messages {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.message {
  display: flex;
  flex-direction: column;
}

.bot-message .message-content {
  background: #f3f4f6;
  color: #1a1a1a;
  border-radius: 18px 18px 18px 4px;
  padding: 12px 16px;
  max-width: 85%;
  font-size: 14px;
  line-height: 1.4;
}

.user-message {
  align-items: flex-end;
}

.user-message .message-content {
  background: #3366cc;
  color: white;
  border-radius: 18px 18px 4px 18px;
  padding: 12px 16px;
  max-width: 85%;
  font-size: 14px;
  line-height: 1.4;
}

.chatbot-input-container {
  display: flex;
  padding: 16px 20px 10px;
  gap: 12px;
}

.chatbot-input {
  flex: 1;
  border: 2px solid #e5e7eb;
  border-radius: 24px;
  padding: 12px 16px;
  font-size: 14px;
  outline: none;
  transition: border-color 0.2s ease;
}

.chatbot-input:focus {
  border-color: #3366cc;
}

.chatbot-send {
  background: #3366cc;
  color: white;
  border: none;
  border-radius: 50%;
  width: 44px;
  height: 44px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s ease;
}

.chatbot-send:hover {
  background: #2954b3;
}

.chatbot-suggestions {
  padding: 10px 20px 20px;
}

.suggestion-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.suggestion-chip {
  background: rgba(51, 102, 204, 0.1);
  color: #3366cc;
  border: 1px solid rgba(51, 102, 204, 0.2);
  border-radius: 16px;
  padding: 6px 12px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.suggestion-chip:hover {
  background: rgba(51, 102, 204, 0.2);
}

.language-buttons {
  display: flex;
  gap: 6px;
  justify-content: flex-end;
  margin-top: 12px;
}

.lang-btn {
  background: rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(10px) saturate(1.8);
  -webkit-backdrop-filter: blur(10px) saturate(1.8);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 10px;
  padding: 4px 8px;
  font-size: 10px;
  font-weight: 600;
  color: #6b7280;
  cursor: pointer;
  transition: all 0.3s ease;
  user-select: none;
}

.lang-btn:hover {
  background: rgba(255, 255, 255, 0.4);
  border: 1px solid rgba(255, 255, 255, 0.3);
  transform: translateY(-1px);
}

.lang-btn.active {
  background: rgba(51, 102, 204, 0.2);
  border: 1px solid rgba(51, 102, 204, 0.3);
  color: #3366cc;
  box-shadow: 0 2px 8px rgba(51, 102, 204, 0.2);
}

/* AI Info tooltip styles */
.ai-info-wrapper {
  position: relative;
  display: inline-block;
  margin-right: 8px;
}

.ai-info-trigger {
  display: flex;
  align-items: center;
  cursor: pointer;
  transition: all 0.2s ease;
  padding: 4px 6px;
  border-radius: 12px;
  background: rgba(128, 128, 128, 0.05);
}

.ai-info-trigger:hover {
  background: rgba(128, 128, 128, 0.1);
}

.ai-info-icon {
  width: 18px;
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #666;
  margin-right: 4px;
}

.ai-info-text {
  font-size: 9px;
  color: #666;
  white-space: nowrap;
  font-weight: 400;
}

.ai-info-trigger:hover .ai-info-icon,
.ai-info-trigger:hover .ai-info-text {
  color: #333;
}

.ai-info-tooltip {
  position: absolute;
  bottom: 100%;
  left: 0;
  margin-bottom: 8px;
  background: rgba(0, 0, 0, 0.95);
  color: white;
  padding: 16px 20px;
  border-radius: 12px;
  min-width: 350px;
  max-width: 400px;
  font-size: 13px;
  line-height: 1.5;
  opacity: 0;
  visibility: hidden;
  transform: translateY(10px);
  transition: all 0.3s ease;
  z-index: 1000;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  pointer-events: none;
  backdrop-filter: blur(10px);
}

.ai-info-tooltip::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 20px;
  width: 0;
  height: 0;
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
  border-top: 8px solid rgba(0, 0, 0, 0.95);
}

.ai-info-tooltip.show {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
  pointer-events: auto;
}

.tooltip-close {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 24px;
  height: 24px;
  border: none;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #fff;
  transition: all 0.2s ease;
  z-index: 1001;
}

.tooltip-close:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: scale(1.1);
}

.ai-info-tooltip h4 {
  margin: 0 0 12px 0;
  font-size: 15px;
  font-weight: 600;
  color: #4fc3f7;
}

.ai-info-tooltip p {
  margin: 8px 0;
  font-size: 12px;
}

.ai-info-tooltip strong {
  color: #e3f2fd;
  font-weight: 600;
}

.ai-info-tooltip em {
  color: #81c784;
  font-style: normal;
  font-weight: 500;
}

.ai-info-tooltip a {
  color: #4fc3f7;
  text-decoration: none;
  font-weight: 500;
}

.ai-info-tooltip a:hover {
  text-decoration: underline;
}

/* Mobile responsive */
@media (max-width: 768px) {
  .chatbot-container {
    bottom: 15px;
    right: 15px;
    left: 15px;
  }
  
  .chatbot-window {
    width: 100%;
    height: 70vh;
    bottom: 70px;
    left: 0;
    right: 0;
    position: fixed;
  }
  
  .chatbot-toggle {
    width: fit-content;
    margin-left: auto;
  }
  
  .chatbot-text {
    display: none;
  }
}
</style>

<script>
// Chatbot Knowledge Base (injected from Jekyll data)
const knowledgeBase = {{ site.data.chatbot_knowledge | jsonify }};

// Chatbot functionality
document.addEventListener('DOMContentLoaded', function() {
  const chatbotToggle = document.getElementById('chatbot-toggle');
  const chatbotWindow = document.getElementById('chatbot-window');
  const chatbotClose = document.getElementById('chatbot-close');
  const aiSearchBtn = document.getElementById('ai-search');
  const chatbotInput = document.getElementById('chatbot-input');
  const chatbotSend = document.getElementById('chatbot-send');
  const chatbotMessages = document.getElementById('chatbot-messages');
  const suggestionChips = document.querySelectorAll('.suggestion-chip');
  
  // Mode toggle elements
  const modeToggle = document.getElementById('mode-toggle');
  const searchLabel = document.querySelector('.search-label');
  const aiLabel = document.querySelector('.ai-label');
  const chatbotSubtitle = document.querySelector('.chatbot-subtitle');
  const chatbotTitle = document.querySelector('.chatbot-title');
  
  
  // Language button elements
  const langButtons = document.querySelectorAll('.lang-btn');
  const suggestionChipsElements = document.querySelectorAll('.suggestion-chip');
  
  // Current modes
  let isAIMode = false;
  let isEnglish = false;
  let selectedModel = 'qwen3-4b';

  // AI Server availability check
  let isServerAvailable = null;
  
  // Get API endpoints based on selected model
  function getModelEndpoints(model) {
    const endpoints = {
      'qwen3-4b': {
        health: 'https://susan-britney-disc-wright.trycloudflare.com/health',
        chat: 'https://susan-britney-disc-wright.trycloudflare.com/chat',
        generate: 'https://susan-britney-disc-wright.trycloudflare.com/generate'
      },
    };
    return endpoints[model] || endpoints['qwen3-4b'];
  }

  // Check if AI server is available
  async function checkAIServer() {
    // Reset availability status when checking different models
    isServerAvailable = null;
    
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);
      const endpoints = getModelEndpoints(selectedModel);
      
      const response = await fetch(endpoints.health, {
        method: 'GET',
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      isServerAvailable = response.ok;
      
      if (isServerAvailable) {
        console.log('✅ AI 서버 연결 성공!');
      }
    } catch (error) {
      console.log('❌ AI server not available:', error.message);
      
      // Show specific error message for certificate issues
      if (error.message.includes('certificate') || error.message.includes('SSL')) {
        console.warn('🌐 AI 서버 연결에 문제가 발생했습니다. 잠시 후 다시 시도해주세요.');
      }
      
      isServerAvailable = false;
    }
    
    return isServerAvailable;
  }

  // Generate AI response using public AI server with auto-save
  async function generateAIResponse(question) {
    try {
      const endpoints = getModelEndpoints(selectedModel);
      
      // Call chat endpoint with auto-save functionality
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
      
      const response = await fetch(endpoints.chat, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          question: question,
          language: isEnglish ? 'en' : 'ko'
        }),
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`Server error: ${response.status}`);
      }

      const data = await response.json();
      console.log('AI Response:', data);
      
      // Show success message if auto-saved
      if (data.auto_saved) {
        console.log('✅ AI 대화가 GitHub에 자동 저장되었습니다!');
      }
      
      return {
        response: data.response || (isEnglish ? "Sorry, no response generated." : "응답을 생성할 수 없습니다."),
        response_time: data.response_time
      };
      
    } catch (error) {
      console.error('Error calling AI server:', error);
      
      // Fallback to basic generate endpoint
      try {
        const endpoints = getModelEndpoints(selectedModel);
        const fallbackResponse = await fetch(endpoints.generate, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            prompt: question,
            language: isEnglish ? 'en' : 'ko'
          })
        });
        
        if (fallbackResponse.ok) {
          const fallbackData = await fallbackResponse.json();
          return fallbackData.response || (isEnglish ? "Sorry, no response generated." : "응답을 생성할 수 없습니다.");
        }
      } catch (fallbackError) {
        console.error('Fallback also failed:', fallbackError);
      }
      
      // Check if server is not running or blocked by network
      if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
        const modelName = 'Qwen3-4B';
        return isEnglish ? 
          "🌐 AI server is not accessible from external networks. Please use GitHub Issues for AI questions: https://github.com/ssurealitylab-spec/Realitylab-site/issues/new?labels=ai-question&template=ai-question.md" :
          `🤖 ${modelName} AI 서버가 일시적으로 사용할 수 없습니다. 잠시 후 다시 시도하거나 GitHub Issue를 이용해주세요.`;
      }
      
      return isEnglish ? 
        "Sorry, I encountered an error. Please try again." :
        "죄송합니다. 오류가 발생했습니다. 다시 시도해주세요.";
    }
  }

  // Toggle chatbot (global function)
  window.toggleChatbot = function() {
    const container = document.getElementById('chatbot-container');
    const chatbotWindow = document.getElementById('chatbot-window');
    if (chatbotWindow.style.display === 'flex') {
      chatbotWindow.style.display = 'none';
    } else {
      container.style.display = 'block';
      chatbotWindow.style.display = 'flex';
    }
  }
  
  // AI Search button in navigation
  if (aiSearchBtn) {
    aiSearchBtn.addEventListener('click', (e) => {
      e.preventDefault();
      window.toggleChatbot();
    });
  }
  
  // Also look for AI button by id
  const aiButtonById = document.getElementById('ai-search');
  if (aiButtonById) {
    aiButtonById.addEventListener('click', (e) => {
      e.preventDefault();
      window.toggleChatbot();
    });
  }
  
  // Look for AI Chat triggers by class name
  const aiChatTriggers = document.querySelectorAll('.ai-chat-trigger');
  aiChatTriggers.forEach(trigger => {
    trigger.addEventListener('click', (e) => {
      e.preventDefault();
      console.log('AI Chat trigger clicked');
      window.toggleChatbot();
    });
  });
  
  // Also look for any element with AI-related classes (fallback)
  const aiButtons = document.querySelectorAll('[href="#ai"], [href="#"], .ai-search-btn, a[title="AI"]');
  aiButtons.forEach(btn => {
    if (btn.textContent.includes('AI') || btn.id === 'ai-search' || btn.href?.includes('#ai')) {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        console.log('AI fallback trigger clicked');
        window.toggleChatbot();
      });
    }
  });

  chatbotClose.addEventListener('click', () => {
    const container = document.getElementById('chatbot-container');
    chatbotWindow.style.display = 'none';
    container.style.display = 'none';
  });

  // Mode toggle functionality - Switch between Search and AI Server
  if (modeToggle) {
    modeToggle.addEventListener('change', function() {
      isAIMode = this.checked;
      updateModeUI();
      
      // Show/hide model selection dropdown
      
      // Check AI server when switching to AI mode
      if (isAIMode) {
        checkAIServer();
      }
    });
  }
  

  // Initialize in search mode by default
  updateAllUI();

  function updateModeUI() {
    updateAllUI();
  }

  // Language button functionality
  langButtons.forEach(btn => {
    btn.addEventListener('click', function() {
      const lang = this.getAttribute('data-lang');
      isEnglish = (lang === 'en');
      updateLanguageUI();
    });
  });

  function updateLanguageUI() {
    updateAllUI();
  }

  function updateAllUI() {
    // Update language button states
    langButtons.forEach(btn => {
      const lang = btn.getAttribute('data-lang');
      if ((lang === 'en' && isEnglish) || (lang === 'ko' && !isEnglish)) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });

    // Update suggestion chips
    suggestionChipsElements.forEach(chip => {
      if (isEnglish) {
        const englishText = chip.getAttribute('data-question-en');
        const englishLabels = ['Research Areas', 'Team Members', 'Application', 'Contact'];
        const index = Array.from(suggestionChipsElements).indexOf(chip);
        chip.textContent = englishLabels[index];
        chip.setAttribute('data-question', englishText);
      } else {
        const koreanText = chip.getAttribute('data-question');
        const koreanLabels = ['연구 분야', '팀 구성원', '지원 방법', '연락처'];
        const index = Array.from(suggestionChipsElements).indexOf(chip);
        chip.textContent = koreanLabels[index];
      }
    });

    // Update mode labels and content based on current language
    if (isAIMode) {
      searchLabel.classList.remove('active');
      aiLabel.classList.add('active');
      if (isEnglish) {
        chatbotTitle.textContent = 'Reality Lab Assistant';
        chatbotSubtitle.textContent = 'AI will answer about our research lab!';
        chatbotInput.placeholder = 'Ask AI anything about our lab...';
      } else {
        chatbotTitle.textContent = 'Reality Lab Assistant';
        chatbotSubtitle.textContent = 'AI가 연구실에 대해 답변해드립니다!';
        chatbotInput.placeholder = 'AI에게 궁금한 것을 물어보세요...';
      }
    } else {
      searchLabel.classList.add('active');
      aiLabel.classList.remove('active');
      if (isEnglish) {
        chatbotTitle.textContent = 'Reality Lab Assistant';
        chatbotSubtitle.textContent = 'Ask anything about our research lab!';
        chatbotInput.placeholder = 'Ask anything about our lab...';
      } else {
        chatbotTitle.textContent = 'Reality Lab Assistant';
        chatbotSubtitle.textContent = '연구실에 대해 궁금한 것을 물어보세요!';
        chatbotInput.placeholder = '궁금한 것을 물어보세요...';
      }
    }
  }

  // Handle input
  async function handleSend() {
    const question = chatbotInput.value.trim();
    if (!question) return;

    // Add user message
    addMessage(question, 'user');
    chatbotInput.value = '';

    // Generate and add bot response
    if (isAIMode) {
      // AI mode - use Tiny Llama
      try {
        addMessage(isEnglish ? 'Thinking...' : '생각 중...', 'bot', true); // temporary loading message
        const aiResult = await generateAIResponse(question);
        // Clear thinking timer
        clearThinkingTimer();
        // Remove the loading message and add the real response
        const messages = chatbotMessages.querySelectorAll('.message');
        const lastMessage = messages[messages.length - 1];
        if (lastMessage && lastMessage.classList.contains('bot-message')) {
          lastMessage.remove();
        }
        const response = aiResult?.response || aiResult || 'No response';
        const responseTime = aiResult?.response_time || null;
        addMessage(response, 'bot', responseTime);
      } catch (error) {
        console.error('Error in AI response:', error);
        // Clear thinking timer on error
        clearThinkingTimer();
        // Remove the loading message on error
        const messages = chatbotMessages.querySelectorAll('.message');
        const lastMessage = messages[messages.length - 1];
        if (lastMessage && lastMessage.classList.contains('bot-message') && (lastMessage.textContent.includes('생각 중') || lastMessage.textContent.includes('Thinking'))) {
          lastMessage.remove();
        }
        addMessage(
          isEnglish ? 'Sorry, I encountered an error. Please try again.' : '죄송합니다. 오류가 발생했습니다. 다시 시도해주세요.',
          'bot'
        );
      }
    } else {
      // Search mode - use existing knowledge base
      setTimeout(() => {
        const answer = generateAnswer(question);
        addMessage(answer, 'bot');
      }, 500);
    }
  }

  chatbotSend.addEventListener('click', handleSend);
  chatbotInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      handleSend();
    }
  });

  // Suggestion chips
  suggestionChips.forEach(chip => {
    chip.addEventListener('click', () => {
      const question = chip.dataset.question;
      chatbotInput.value = question;
      handleSend();
    });
  });

  // Timer variables
  let thinkingTimer = null;
  let thinkingStartTime = null;

  // Add message to chat
  function addMessage(content, type, responseTime = null) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}-message`;
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';
    contentDiv.innerHTML = content.replace(/\n/g, '<br>');
    
    messageDiv.appendChild(contentDiv);
    
    // Add response time for bot messages
    if (type === 'bot' && responseTime !== null) {
      const timeDiv = document.createElement('div');
      timeDiv.className = 'response-time';
      timeDiv.innerHTML = `<small style="color: #888; font-size: 11px;">응답 시간: ${responseTime}초</small>`;
      messageDiv.appendChild(timeDiv);
    }
    
    chatbotMessages.appendChild(messageDiv);
    
    // Start real-time timer for thinking messages after DOM insertion
    if (type === 'bot' && (content.includes('생각 중') || content.includes('Thinking'))) {
      const timeDiv = document.createElement('div');
      timeDiv.className = 'thinking-timer';
      timeDiv.innerHTML = `<small style="color: #888; font-size: 11px;">⏱️ 0초</small>`;
      messageDiv.appendChild(timeDiv);
      
      // Start timer
      thinkingStartTime = Date.now();
      thinkingTimer = setInterval(() => {
        const elapsed = Math.floor((Date.now() - thinkingStartTime) / 1000);
        const timerElement = messageDiv.querySelector('.thinking-timer small');
        if (timerElement) {
          timerElement.innerHTML = `⏱️ ${elapsed}초`;
        } else {
          clearInterval(thinkingTimer);
        }
      }, 1000);
    }
    
    // Scroll to bottom
    chatbotMessages.scrollTop = chatbotMessages.scrollHeight;
  }


  // Clear thinking timer
  function clearThinkingTimer() {
    if (thinkingTimer) {
      clearInterval(thinkingTimer);
      thinkingTimer = null;
      thinkingStartTime = null;
    }
  }

  // Simple knowledge-based answer generation
  function generateAnswer(question) {
    const q = question.toLowerCase();
    
    // Contact info (with language toggle) - Check this FIRST
    if (q.includes('연락') || q.includes('이메일') || q.includes('전화') || q.includes('연락처') || 
        q.includes('contact') || q.includes('email') || q.includes('phone') || q.includes('number')) {
      
      const labInfo = isEnglish ? knowledgeBase.lab_info.en : knowledgeBase.lab_info.ko;
      
      if (isEnglish) {
        return `Contact Information:\n• Email: ${labInfo.email}\n• Phone: ${labInfo.phone}\n• Location: ${labInfo.location}`;
      } else {
        return `연락처 정보입니다:\n• 이메일: ${labInfo.email}\n• 전화: ${labInfo.phone}\n• 위치: ${labInfo.location}`;
      }
    }
    
    // Check custom Q&A after language-specific responses
    const customQAs = isEnglish ? knowledgeBase.custom_qa.en : knowledgeBase.custom_qa.ko;
    for (const qa of customQAs) {
      // Check question match
      if (q.includes(qa.question.toLowerCase()) || 
          qa.question.toLowerCase().includes(q) ||
          checkSimilarity(q, qa.question.toLowerCase())) {
        return qa.answer;
      }
      
      // Check keywords match
      if (qa.keywords) {
        for (const keyword of qa.keywords) {
          if (q.includes(keyword.toLowerCase())) {
            return qa.answer;
          }
        }
      }
    }
    
    // Research areas (with language toggle)
    for (const area of knowledgeBase.research_areas) {
      const areaKo = area.ko;
      const areaEn = area.en;
      
      for (const keyword of [...areaKo.keywords, ...areaEn.keywords]) {
        if (q.includes(keyword.toLowerCase()) || 
            q.includes(areaKo.name.toLowerCase()) || 
            q.includes(areaEn.name.toLowerCase())) {
          
          if (isEnglish) {
            return `${areaEn.name}: ${areaEn.description}`;
          } else {
            return `${areaKo.name}: ${areaKo.description}`;
          }
        }
      }
    }
    
    // Team members (with language toggle)
    if (q.includes('팀') || q.includes('구성원') || q.includes('멤버') || q.includes('사람') ||
        q.includes('team') || q.includes('member') || q.includes('people') || q.includes('staff')) {
      
      let teamInfo;
      
      if (isEnglish) {
        teamInfo = "Let me introduce Reality Lab team members:\n\n";
        knowledgeBase.team_members.en.forEach(member => {
          teamInfo += `• ${member.name} - ${member.role}\n`;
        });
      } else {
        teamInfo = "Reality Lab 팀 구성원들을 소개해드릴게요:\n\n";
        knowledgeBase.team_members.ko.forEach(member => {
          teamInfo += `• ${member.name} - ${member.role}\n`;
        });
      }
      return teamInfo;
    }
    
    // Lab info (with language toggle)
    if (q.includes('연구실') || q.includes('랩') || q.includes('소개') ||
        q.includes('lab') || q.includes('about') || q.includes('introduction') || q.includes('info')) {
      
      const labInfo = isEnglish ? knowledgeBase.lab_info.en : knowledgeBase.lab_info.ko;
      
      if (isEnglish) {
        return `${labInfo.full_name} was established in ${labInfo.established}. Led by ${labInfo.director}, ${labInfo.mission}`;
      } else {
        return `${labInfo.full_name}은 ${labInfo.established}년에 설립되었습니다. ${labInfo.director}님이 이끄시며, ${labInfo.mission}`;
      }
    }
    // Location (with language toggle)
    if (q.includes('위치') || q.includes('어디') || q.includes('location') || q.includes('where') || q.includes('address')) {
      const labInfo = isEnglish ? knowledgeBase.lab_info.en : knowledgeBase.lab_info.ko;
      
      if (isEnglish) {
        return `Reality Lab is located at ${labInfo.location}.`;
      } else {
        return `Reality Lab은 ${labInfo.location}에 위치하고 있습니다.`;
      }
    }
    
    // Fallback
    const fallbacks = knowledgeBase.fallback_responses;
    return fallbacks[Math.floor(Math.random() * fallbacks.length)];
  }

  // Simple similarity check
  function checkSimilarity(str1, str2) {
    const words1 = str1.split(' ');
    const words2 = str2.split(' ');
    let matchCount = 0;
    
    words1.forEach(word1 => {
      if (words2.some(word2 => word2.includes(word1) || word1.includes(word2))) {
        matchCount++;
      }
    });
    
    return matchCount >= Math.min(words1.length, words2.length) * 0.4;
  }

  // Drag functionality
  let isDragging = false;
  let currentX = 0;
  let currentY = 0;
  let initialX = 0;
  let initialY = 0;
  let xOffset = 0;
  let yOffset = 0;

  const chatbotHeader = document.querySelector('.chatbot-header');
  
  if (chatbotHeader) {
    chatbotHeader.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', dragMove);
    document.addEventListener('mouseup', dragEnd);
  }

  function dragStart(e) {
    if (e.target === chatbotClose || e.target.closest('.chatbot-close')) return;
    
    initialX = e.clientX - xOffset;
    initialY = e.clientY - yOffset;

    if (e.target === chatbotHeader || chatbotHeader.contains(e.target)) {
      isDragging = true;
      chatbotWindow.style.transition = 'none';
    }
  }

  function dragMove(e) {
    if (isDragging) {
      e.preventDefault();
      currentX = e.clientX - initialX;
      currentY = e.clientY - initialY;

      xOffset = currentX;
      yOffset = currentY;

      // Convert to fixed positioning when dragging
      if (chatbotWindow.style.position !== 'fixed') {
        const rect = chatbotWindow.getBoundingClientRect();
        chatbotWindow.style.position = 'fixed';
        chatbotWindow.style.bottom = 'auto';
        chatbotWindow.style.right = 'auto';
        chatbotWindow.style.top = rect.top + 'px';
        chatbotWindow.style.left = rect.left + 'px';
      }

      chatbotWindow.style.transform = `translate(${currentX}px, ${currentY}px)`;
    }
  }

  function dragEnd(e) {
    initialX = currentX;
    initialY = currentY;
    isDragging = false;
    chatbotWindow.style.transition = '';
  }

  // AI Info tooltip functionality
  const aiInfoTrigger = document.getElementById('ai-info-trigger');
  const aiInfoTooltip = document.getElementById('ai-info-tooltip');
  const aiInfoText = document.getElementById('ai-info-text');
  const tooltipClose = document.getElementById('tooltip-close');
  const tooltipKo = aiInfoTooltip.querySelector('.tooltip-ko');
  const tooltipEn = aiInfoTooltip.querySelector('.tooltip-en');
  
  let tooltipTimeout;
  let isTooltipPinned = false; // Track if tooltip is pinned (clicked)

  function updateAIInfoText() {
    if (isEnglish) {
      aiInfoText.textContent = 'How does this AI work?';
    } else {
      aiInfoText.textContent = '이 AI는 어떻게 동작하나요?';
    }
  }

  function showAIInfoTooltip() {
    clearTimeout(tooltipTimeout);
    
    // Show correct language tooltip
    if (isEnglish) {
      tooltipKo.style.display = 'none';
      tooltipEn.style.display = 'block';
    } else {
      tooltipKo.style.display = 'block';
      tooltipEn.style.display = 'none';
    }
    
    aiInfoTooltip.classList.add('show');
  }

  function hideAIInfoTooltip() {
    if (!isTooltipPinned) {
      tooltipTimeout = setTimeout(() => {
        aiInfoTooltip.classList.remove('show');
      }, 300);
    }
  }

  function forceHideTooltip() {
    isTooltipPinned = false;
    clearTimeout(tooltipTimeout);
    aiInfoTooltip.classList.remove('show');
  }

  if (aiInfoTrigger && aiInfoTooltip) {
    // Show on hover
    aiInfoTrigger.addEventListener('mouseenter', showAIInfoTooltip);
    aiInfoTrigger.addEventListener('mouseleave', hideAIInfoTooltip);
    
    // Pin on click
    aiInfoTrigger.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      if (aiInfoTooltip.classList.contains('show') && isTooltipPinned) {
        forceHideTooltip();
      } else {
        showAIInfoTooltip();
        isTooltipPinned = true;
      }
    });

    // Keep tooltip visible when hovering over it
    aiInfoTooltip.addEventListener('mouseenter', () => {
      clearTimeout(tooltipTimeout);
    });
    
    aiInfoTooltip.addEventListener('mouseleave', hideAIInfoTooltip);
    
    // Close button functionality
    if (tooltipClose) {
      tooltipClose.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        forceHideTooltip();
      });
    }
    
    // Close when clicking outside
    document.addEventListener('click', function(e) {
      if (!aiInfoTrigger.contains(e.target) && !aiInfoTooltip.contains(e.target)) {
        forceHideTooltip();
      }
    });
    
    // Update tooltip and text language when language buttons are clicked
    const langBtns = document.querySelectorAll('.lang-btn');
    langBtns.forEach(btn => {
      const originalClickHandler = btn.onclick;
      btn.onclick = function(e) {
        if (originalClickHandler) {
          originalClickHandler.call(this, e);
        }
        
        // Update AI info text
        setTimeout(() => {
          updateAIInfoText();
          
          // Update tooltip if it's currently shown
          if (aiInfoTooltip.classList.contains('show')) {
            if (isEnglish) {
              tooltipKo.style.display = 'none';
              tooltipEn.style.display = 'block';
            } else {
              tooltipKo.style.display = 'block';
              tooltipEn.style.display = 'none';
            }
          }
        }, 50);
      };
    });
    
    // Initialize text on page load
    updateAIInfoText();
  }
});
</script>